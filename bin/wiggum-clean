#!/usr/bin/env bash
# Clean up Chief Wiggum worktrees and worker directories
set -euo pipefail

WIGGUM_HOME="${WIGGUM_HOME:-$HOME/.claude/chief-wiggum}"
PROJECT_DIR="$(pwd)"
RALPH_DIR="${RALPH_DIR:-$PROJECT_DIR/.ralph}"

source "$WIGGUM_HOME/lib/core/exit-codes.sh"
source "$WIGGUM_HOME/lib/core/defaults.sh"
source "$WIGGUM_HOME/lib/core/file-lock.sh"
source "$WIGGUM_HOME/lib/worker/worker-lifecycle.sh"
source "$WIGGUM_HOME/lib/tasks/task-parser.sh"

SKIP_CONFIRM=false

show_help() {
    cat << EOF
wiggum clean - Clean up worktrees, worker directories, or reset kanban tasks

Usage: wiggum clean [options] <target>
       wiggum clean kanban [all|<task-id>]

Worker Targets:
  <pattern>           Clean workers matching pattern (e.g., TASK-001, 030)
  <p1>,<p2>,...       Clean multiple patterns (comma-separated)
  all                 Clean all worktrees and worker directories
  done                Clean workers whose PRs have been merged

Kanban Targets:
  kanban all          Reset resettable tasks (in-progress, pending approval, failed)
  kanban <task-id>    Reset a specific task if it's in a resettable state

Options:
  -y, --yes           Skip confirmation prompt
  -h, --help          Show this help message

Examples:
  wiggum clean TASK-001       # Clean workers matching TASK-001
  wiggum clean 030            # Clean workers matching "030"
  wiggum clean all            # Clean up all worktrees and worker directories
  wiggum clean done           # Clean workers with merged PRs
  wiggum clean -y all         # Clean all without confirmation
  wiggum clean kanban all     # Reset all resettable tasks in kanban
  wiggum clean kanban 030     # Reset TASK-030 if it's resettable

EOF
}

log() {
    echo "[$(date -Iseconds)] $*"
}

confirm() {
    local prompt="$1"
    [ "$SKIP_CONFIRM" = true ] && return 0
    read -r -p "$prompt [y/N] " response
    [[ "$response" =~ ^[yY]([eE][sS])?$ ]]
}

# Check if a PR is merged
is_pr_merged() {
    local pr_url="$1"
    [ -z "$pr_url" ] || [ "$pr_url" = "N/A" ] && return 1
    command -v gh &>/dev/null || return 1

    local pr_state
    pr_state=$(gh pr view "$pr_url" --json state -q .state 2>/dev/null) || return 1
    [ "$pr_state" = "MERGED" ]
}

# Find workers with merged PRs
find_workers_with_merged_prs() {
    [ -d "$RALPH_DIR/workers" ] || return

    for dir in "$RALPH_DIR/workers"/worker-*; do
        [ -d "$dir" ] || continue
        local pr_url_file="$dir/pr_url.txt"
        [ -f "$pr_url_file" ] || continue

        if is_pr_merged "$(cat "$pr_url_file")"; then
            basename "$dir"
        fi
    done
}

clean_worker() {
    local worker_dir="$RALPH_DIR/workers/$1"

    if [ -d "$worker_dir/workspace" ]; then
        log "Removing worktree: $worker_dir/workspace"
        git worktree remove "$worker_dir/workspace" --force 2>/dev/null || true
    fi

    if [ -d "$worker_dir" ]; then
        log "Removing worker directory: $1"
        rm -rf "$worker_dir"
    fi
}

# Resolve patterns to worker directories
resolve_patterns() {
    local input="$1"
    local resolved=()

    IFS=',' read -ra patterns <<< "$input"
    for pattern in "${patterns[@]}"; do
        pattern=$(echo "$pattern" | xargs)
        [ -z "$pattern" ] && continue

        local matches
        matches=$(find_workers_by_pattern "$RALPH_DIR" "$pattern")

        if [ -z "$matches" ]; then
            echo "No workers found matching: $pattern" >&2
            return 1
        fi

        local match_count
        match_count=$(echo "$matches" | wc -l | tr -d '[:space:]')

        if [ "$match_count" -gt 1 ]; then
            echo "Multiple workers match '$pattern':" >&2
            sed 's/^/  /' <<< "$matches" >&2
            echo "Please be more specific." >&2
            return 1
        fi

        resolved+=("$(echo "$matches" | head -1)")
    done

    printf '%s\n' "${resolved[@]}"
}

do_clean() {
    local workers=("$@")

    for worker in "${workers[@]}"; do
        clean_worker "$worker"
    done

    git worktree prune 2>/dev/null
    log "Cleaned ${#workers[@]} worker(s)"
    echo ""
    log "Current status:"
    git worktree list
}

# Status character to human-readable name
status_name() {
    case "$1" in
        " ") echo "pending" ;;
        "=") echo "in-progress" ;;
        "P") echo "pending approval" ;;
        "x") echo "complete" ;;
        "*") echo "failed" ;;
        "N") echo "not planned" ;;
        *)   echo "unknown" ;;
    esac
}

# Reset kanban tasks to pending
do_kanban_reset() {
    local kanban_file="$1"
    shift
    local tasks=("$@")

    for task_id in "${tasks[@]}"; do
        log "Resetting $task_id to pending"
        update_kanban_status "$kanban_file" "$task_id" " "
    done

    log "Reset ${#tasks[@]} task(s) to pending"
}

# Handle 'wiggum clean kanban all'
do_kanban_all() {
    local kanban_file="$RALPH_DIR/kanban.md"

    [ -f "$kanban_file" ] || {
        echo "ERROR: No kanban file found at $kanban_file"
        exit $EXIT_WORKER_NO_KANBAN
    }

    local wip_tasks failed_tasks pending_approval_tasks
    wip_tasks=$(get_in_progress_tasks "$kanban_file")
    failed_tasks=$(get_failed_tasks "$kanban_file")
    pending_approval_tasks=$(get_pending_approval_tasks "$kanban_file")

    local wip_count=0 failed_count=0 pa_count=0
    [ -n "$wip_tasks" ] && wip_count=$(echo "$wip_tasks" | wc -l | tr -d '[:space:]')
    [ -n "$failed_tasks" ] && failed_count=$(echo "$failed_tasks" | wc -l | tr -d '[:space:]')
    [ -n "$pending_approval_tasks" ] && pa_count=$(echo "$pending_approval_tasks" | wc -l | tr -d '[:space:]')

    echo "Resettable tasks in kanban:"
    echo "  [=] In-progress:      $wip_count"
    echo "  [P] Pending approval: $pa_count"
    echo "  [*] Failed:           $failed_count"
    echo ""

    if [ "$wip_count" -eq 0 ] && [ "$pa_count" -eq 0 ] && [ "$failed_count" -eq 0 ]; then
        echo "No tasks to reset."
        exit $EXIT_OK
    fi

    local tasks_to_reset=()

    [ -n "$wip_tasks" ] && while IFS= read -r task; do
        tasks_to_reset+=("$task")
    done <<< "$wip_tasks"

    if [ "$pa_count" -gt 0 ] || [ "$failed_count" -gt 0 ]; then
        if [ "$SKIP_CONFIRM" = true ] || confirm "Also reset [P] pending approval and [*] failed tasks?"; then
            [ -n "$failed_tasks" ] && while IFS= read -r task; do
                tasks_to_reset+=("$task")
            done <<< "$failed_tasks"
            [ -n "$pending_approval_tasks" ] && while IFS= read -r task; do
                tasks_to_reset+=("$task")
            done <<< "$pending_approval_tasks"
        fi
    fi

    [ ${#tasks_to_reset[@]} -eq 0 ] && {
        echo "No tasks selected for reset."
        exit $EXIT_OK
    }

    echo "The following tasks will be reset to pending [ ]:"
    for task in "${tasks_to_reset[@]}"; do
        local status
        status=$(get_task_status "$kanban_file" "$task")
        echo "  [$status] $task"
    done
    echo ""

    confirm "Proceed with reset?" || {
        echo "Aborted."
        exit $EXIT_OK
    }

    do_kanban_reset "$kanban_file" "${tasks_to_reset[@]}"
}

# Handle 'wiggum clean kanban <task-id>'
do_kanban_task() {
    local task_pattern="$1"
    local kanban_file="$RALPH_DIR/kanban.md"

    [ -f "$kanban_file" ] || {
        echo "ERROR: No kanban file found at $kanban_file"
        exit $EXIT_WORKER_NO_KANBAN
    }

    local task_id
    task_id=$(resolve_task_id "$kanban_file" "$task_pattern") || exit $EXIT_WORKER_TASK_NOT_FOUND

    local status
    status=$(get_task_status "$kanban_file" "$task_id")

    case "$status" in
        "="|"P"|"*")
            echo "Task $task_id is currently $(status_name "$status") [$status]"
            echo ""
            confirm "Reset to pending [ ]?" || {
                echo "Aborted."
                exit $EXIT_OK
            }
            do_kanban_reset "$kanban_file" "$task_id"
            ;;
        *)
            echo "Task $task_id is $(status_name "$status") [$status] - not a resettable state."
            echo "Resettable states: [=] in-progress, [P] pending approval, [*] failed"
            exit $EXIT_USAGE
            ;;
    esac
}

# Parse options
TARGET=""
KANBAN_TARGET=""
while [[ $# -gt 0 ]]; do
    case "$1" in
        -y|--yes)
            SKIP_CONFIRM=true
            shift
            ;;
        -h|--help)
            show_help
            exit $EXIT_OK
            ;;
        -*)
            echo "Unknown option: $1"
            show_help
            exit $EXIT_USAGE
            ;;
        kanban)
            TARGET="kanban"
            shift
            [[ $# -gt 0 ]] && [[ ! "$1" =~ ^- ]] && {
                KANBAN_TARGET="$1"
                shift
            }
            ;;
        *)
            [ -z "$TARGET" ] && TARGET="$1" || {
                echo "Unexpected argument: $1"
                exit $EXIT_USAGE
            }
            shift
            ;;
    esac
done

[ -z "$TARGET" ] && {
    echo "No target specified. Use 'wiggum clean <pattern>' or 'wiggum clean all'."
    show_help
    exit $EXIT_OK
}

[ -d "$RALPH_DIR" ] || {
    echo "ERROR: .ralph/ directory not found"
    exit $EXIT_CLEAN_NO_RALPH_DIR
}

# Handle kanban subcommand
if [ "$TARGET" = "kanban" ]; then
    [ -z "$KANBAN_TARGET" ] && {
        echo "No kanban target specified. Use 'wiggum clean kanban all' or 'wiggum clean kanban <task-id>'."
        show_help
        exit $EXIT_USAGE
    }

    [ "$KANBAN_TARGET" = "all" ] && do_kanban_all || do_kanban_task "$KANBAN_TARGET"
    exit $EXIT_OK
fi

# Determine workers to clean
if [ "$TARGET" = "all" ]; then
    workers_to_clean=$(list_all_workers "$RALPH_DIR")
elif [ "$TARGET" = "done" ]; then
    echo "Checking PR status for all workers (this may take a moment)..."
    workers_to_clean=$(find_workers_with_merged_prs)
else
    workers_to_clean=$(resolve_patterns "$TARGET") || exit $EXIT_CLEAN_PATTERN_NOT_FOUND
fi

[ -z "$workers_to_clean" ] && {
    echo "No workers to clean."
    exit $EXIT_OK
}

mapfile -t workers_array <<< "$workers_to_clean"

# Check for running workers
running_workers=()
for worker in "${workers_array[@]}"; do
    is_worker_running "$RALPH_DIR/workers/$worker" && running_workers+=("$worker")
done

[ ${#running_workers[@]} -gt 0 ] && {
    echo "ERROR: Cannot clean running workers. Stop them first with 'wiggum stop <id>'."
    echo ""
    echo "Running workers:"
    printf '  %s\n' "${running_workers[@]}"
    exit $EXIT_CLEAN_WORKERS_RUNNING
}

# Confirm and clean
echo "The following worker directories will be removed:"
printf '  %s\n' "${workers_array[@]}"
echo ""

confirm "Proceed with cleanup?" || {
    echo "Aborted."
    exit $EXIT_OK
}

do_clean "${workers_array[@]}"
